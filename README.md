# Система подбора ближайших водителей

Реализация механизма поиска пяти ближайших водителей на прямоугольной сетке размером N × M. Проект включает три различных алгоритма, покрытые unit-тестами, и сравнение их производительности с использованием BenchmarkDotNet.

## Описание задачи
- Карта представляет собой дискретную прямоугольную сетку размером N × M.
- Каждая клетка сетки (координаты X, Y, где 0 ≤ X < N, 0 ≤ Y < M) может содержать не более одного водителя.
- Каждый водитель имеет уникальный числовой идентификатор.
- Для заданного заказа (точки с координатами X, Y) необходимо найти пять водителей с минимальным евклидовым расстоянием до точки заказа.

## Реализованные алгоритмы
Проект содержит три стратегии поиска, реализующие общий интерфейс INearestDriverFinder.

### SimpleSort

Алгоритм полного перебора всех водителей с последующей сортировкой по расстоянию. Имеет временную сложность O(D log D), где D — общее количество водителей. Наиболее эффективен при небольшом количестве водителей (D < 1000) благодаря простоте и минимальным накладным расходам.

### PriorityQueue

Алгоритм использует макс-кучу (реализованную через стандартный PriorityQueue<T>), чтобы поддерживать набор из пяти текущих ближайших водителей. Временная сложность составляет O(D log K), где K = 5. Эффективен при средних и больших объёмах данных.

### KDTree

Алгоритм основан на пространственной структуре данных KD-дерево. После построения дерева выполняется полный обход для сбора всех точек с последующей сортировкой. Построение дерева имеет сложность O(D log D), но демонстрирует лучшую масштабируемость при очень большом количестве водителей.

## Тестирование

Все алгоритмы покрыты unit-тестами с использованием фреймворка NUnit. Тесты проверяют:
- Корректность расчёта евклидова расстояния.
- Правильный порядок водителей в результирующем списке.
- Обработку крайних случаев (менее пяти водителей на карте, пустая карта).

## Сравнение производительности

Производительность алгоритмов измерена с помощью библиотеки BenchmarkDotNet. Замеры проводились для трёх сценариев с количеством водителей: 100, 1 000 и 10 000.
Из результатов видно, что:
- При малом количестве водителей (100) наиболее быстрым является SimpleSortFinder.
- При увеличении количества водителей преимущество получают PriorityQueueFinder и KDTreeFinder за счёт более эффективных стратегий работы с данными.
